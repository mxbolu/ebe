// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// ENUMS
// ============================================

enum UserRole {
  USER
  MODERATOR
  ADMIN
  SUPER_ADMIN
}

enum ReadingStatus {
  WANT_TO_READ
  CURRENTLY_READING
  FINISHED
  DID_NOT_FINISH
}

enum SubmissionStatus {
  PENDING
  APPROVED
  REJECTED
}

enum BookSource {
  USER_SUBMITTED
  API_IMPORT
  ADMIN_ADDED
  CACHED_FROM_SEARCH
}

enum BadgeType {
  BOOK_CONTRIBUTOR
  EDIT_CONTRIBUTOR
  READING_MILESTONE
  REVIEW_MASTER
  EARLY_ADOPTER
  GENRE_EXPLORER
  READING_STREAK
  SPEED_READER
  BOOKWORM
}

// ============================================
// USER MODELS
// ============================================

model User {
  id                String    @id @default(cuid())
  email             String    @unique
  password          String
  username          String    @unique
  name              String?
  avatar            String?
  bio               String?
  role              UserRole  @default(USER)
  showContributions Boolean   @default(true) // opt-in/out of credit

  // Email verification
  isEmailVerified   Boolean   @default(false)
  verificationOTP   String?
  verificationOTPExpiry DateTime?

  // Password reset
  resetOTP          String?
  resetOTPExpiry    DateTime?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  readingEntries    ReadingEntry[]
  shelves           Shelf[]
  bookSubmissions   BookSubmission[]
  booksAdded        Book[]            @relation("BookAddedBy")
  booksApproved     Book[]            @relation("BookApprovedBy")
  reviewedSubmissions BookSubmission[] @relation("SubmissionReviewer")
  bookEditSuggestions BookEditSuggestion[]
  reviewedEdits     BookEditSuggestion[] @relation("EditReviewer")
  badges            UserBadge[]
  gamificationStats GamificationStats?

  // Phase 3 Relations
  followers         Follow[]          @relation("UserFollowers")
  following         Follow[]          @relation("UserFollowing")
  collections       Collection[]
  readingGoals      ReadingGoal[]
  notes             Note[]
  highlights        Highlight[]
  quotes            Quote[]
  readingSessions   ReadingSession[]
  activities        Activity[]
  userChallenges    UserChallenge[]
  readingStreak     ReadingStreak?
  reviewHelpfuls    ReviewHelpful[]
  reviewComments    ReviewComment[]
  createdBookClubs  BookClub[]       @relation("CreatedBookClubs")
  bookClubMemberships BookClubMember[]
  clubDiscussions   BookClubDiscussion[]
  clubBooksAdded    BookClubBook[]
  notifications     Notification[]
  searchHistory     SearchHistory[]
  createdMeetings   BookClubMeeting[] @relation("CreatedMeetings")

  @@index([email])
  @@index([username])
  @@index([role])
}

// ============================================
// BOOK MODELS
// ============================================

model ImportJob {
  id                String    @id @default(cuid())

  source            String    // "openlibrary", "googlebooks"
  status            String    // "pending", "running", "completed", "failed", "paused"
  totalRecords      Int       @default(0)
  processedRecords  Int       @default(0)
  successCount      Int       @default(0)
  errorCount        Int       @default(0)

  startedAt         DateTime?
  completedAt       DateTime?
  lastProcessedId   String?   // Resume point
  errorMessage      String?   @db.Text

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([status])
  @@index([source])
}

model Book {
  id                  String      @id @default(cuid())
  title               String
  authors             String[]    // Array of author names
  isbn                String?     @unique
  coverImageUrl       String?
  description         String?     @db.Text
  publishedYear       Int?
  genres              String[]    // Array of genres
  pageCount           Int?
  publisher           String?
  language            String?     @default("en")

  // Metadata
  source              BookSource
  addedByUserId       String?
  approvedByUserId    String?
  timesAddedToShelves Int         @default(0)
  averageRating       Float?
  totalRatings        Int         @default(0)

  // External API tracking
  openLibraryId       String?     // Open Library work ID (e.g., "OL45804W")
  googleBooksId       String?     // Google Books volume ID
  goodreadsId         String?     // Goodreads book ID
  lastSyncedAt        DateTime?   // Last time we synced with external API

  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt

  // Relations
  addedBy             User?       @relation("BookAddedBy", fields: [addedByUserId], references: [id])
  approvedBy          User?       @relation("BookApprovedBy", fields: [approvedByUserId], references: [id])
  readingEntries      ReadingEntry[]
  shelfBooks          ShelfBook[]
  editSuggestions     BookEditSuggestion[]

  // Phase 3 Relations
  collectionBooks     CollectionBook[]
  notes               Note[]
  highlights          Highlight[]
  quotes              Quote[]
  readingSessions     ReadingSession[]
  bookClubBooks       BookClubBook[]

  @@index([title])
  @@index([authors])
  @@index([isbn])
  @@index([source])
  @@index([createdAt])
  @@index([openLibraryId])
  @@index([googleBooksId])
  @@index([goodreadsId])
  @@index([publishedYear])
  @@index([averageRating])
  @@index([genres])
  @@index([averageRating, totalRatings])  // Composite for sorting by popularity
  @@index([publishedYear, averageRating]) // Composite for year + rating filters
}

model BookSubmission {
  id                String           @id @default(cuid())

  // Book details
  title             String
  authors           String[]
  isbn              String?
  coverImageUrl     String?
  description       String?          @db.Text
  publishedYear     Int?
  genres            String[]
  pageCount         Int?
  publisher         String?
  language          String?
  submissionNotes   String?          @db.Text

  // Submission metadata
  submittedByUserId String
  status            SubmissionStatus @default(PENDING)
  reviewedByUserId  String?
  reviewNotes       String?          @db.Text

  submittedAt       DateTime         @default(now())
  reviewedAt        DateTime?

  // Relations
  submittedBy       User             @relation(fields: [submittedByUserId], references: [id])
  reviewedBy        User?            @relation("SubmissionReviewer", fields: [reviewedByUserId], references: [id])

  @@index([submittedByUserId])
  @@index([status])
  @@index([submittedAt])
}

model BookEditSuggestion {
  id                String           @id @default(cuid())
  bookId            String
  suggestedByUserId String

  // What's being edited
  field             String           // title, authors, cover, description, etc.
  currentValue      String?          @db.Text
  suggestedValue    String           @db.Text
  reason            String?          @db.Text

  // Review status
  status            SubmissionStatus @default(PENDING)
  reviewedByUserId  String?
  reviewNotes       String?          @db.Text
  reviewedAt        DateTime?

  createdAt         DateTime         @default(now())

  // Relations
  book              Book             @relation(fields: [bookId], references: [id], onDelete: Cascade)
  suggestedBy       User             @relation(fields: [suggestedByUserId], references: [id])
  reviewedBy        User?            @relation("EditReviewer", fields: [reviewedByUserId], references: [id])

  @@index([bookId])
  @@index([status])
  @@index([suggestedByUserId])
}

// ============================================
// READING MODELS
// ============================================

model ReadingEntry {
  id                String         @id @default(cuid())
  userId            String
  bookId            String

  status            ReadingStatus  @default(WANT_TO_READ)
  startDate         DateTime?
  finishDate        DateTime?
  rating            Float?         // 1.0-10.0 scale
  review            String?        @db.Text
  notes             String?        @db.Text
  isFavorite        Boolean        @default(false)
  isPrivate         Boolean        @default(false)

  // Re-read tracking
  readCount         Int            @default(1)  // Number of times read
  lastReadDate      DateTime?                   // Most recent finish date

  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  // Relations
  user              User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  book              Book           @relation(fields: [bookId], references: [id], onDelete: Cascade)
  progress          ReadingProgress?

  // Phase 3 Relations
  tags              ReadingEntryTag[]
  helpfulMarks      ReviewHelpful[]
  comments          ReviewComment[]

  @@unique([userId, bookId]) // User can only have one entry per book
  @@index([userId])
  @@index([bookId])
  @@index([status])
  @@index([userId, status]) // Composite for badge checking (count finished books)
  @@index([bookId, status, isPrivate]) // Composite for fetching book reviews
  @@index([createdAt]) // For sorting reviews by recent
  @@index([rating]) // For sorting reviews by rating
}

model ReadingProgress {
  id                String        @id @default(cuid())
  readingEntryId    String        @unique

  currentPage       Int           @default(0)
  totalPages        Int
  progressPercentage Float        @default(0)

  lastUpdated       DateTime      @updatedAt

  // Relations
  readingEntry      ReadingEntry  @relation(fields: [readingEntryId], references: [id], onDelete: Cascade)

  @@index([readingEntryId])
}

// ============================================
// SHELF/COLLECTION MODELS
// ============================================

model Shelf {
  id                String      @id @default(cuid())
  userId            String

  name              String
  description       String?     @db.Text
  isPublic          Boolean     @default(false)

  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  // Relations
  user              User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  books             ShelfBook[]

  @@index([userId])
}

model ShelfBook {
  id                String      @id @default(cuid())
  shelfId           String
  bookId            String

  addedAt           DateTime    @default(now())

  // Relations
  shelf             Shelf       @relation(fields: [shelfId], references: [id], onDelete: Cascade)
  book              Book        @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([shelfId, bookId]) // Book can only be in a shelf once
  @@index([shelfId])
  @@index([bookId])
}

// ============================================
// GAMIFICATION MODELS
// ============================================

model GamificationStats {
  id                  String    @id @default(cuid())
  userId              String    @unique

  // Contribution points
  booksSubmitted      Int       @default(0)
  booksApproved       Int       @default(0)
  editsSubmitted      Int       @default(0)
  editsApproved       Int       @default(0)

  // Reading points
  booksRead           Int       @default(0)
  pagesRead           Int       @default(0)
  reviewsWritten      Int       @default(0)

  // Total points
  totalPoints         Int       @default(0)
  level               Int       @default(1)

  updatedAt           DateTime  @updatedAt

  // Relations
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([totalPoints])
  @@index([level])
}

model Badge {
  id                  String      @id @default(cuid())
  name                String      @unique
  description         String      @db.Text
  type                BadgeType
  iconUrl             String?
  criteria            String      @db.Text // JSON string describing how to earn it
  points              Int         @default(0)

  createdAt           DateTime    @default(now())

  // Relations
  userBadges          UserBadge[]

  @@index([type]) // For filtering badges by type
  @@index([type, name]) // Composite for badge lookup in checkBadges functions
}

model UserBadge {
  id                  String    @id @default(cuid())
  userId              String
  badgeId             String

  earnedAt            DateTime  @default(now())

  // Relations
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge               Badge     @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId]) // User can only earn each badge once
  @@index([userId])
  @@index([badgeId])
}

model ReadingChallenge {
  id                  String    @id @default(cuid())
  name                String
  description         String    @db.Text
  type                String    // "monthly", "genre", "pages", "author"
  targetValue         Int       // e.g., 5 books, 1000 pages
  startDate           DateTime
  endDate             DateTime
  isActive            Boolean   @default(true)
  iconUrl             String?

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  userChallenges      UserChallenge[]

  @@index([isActive, endDate]) // Composite for fetching active, non-expired challenges
  @@index([startDate]) // For sorting challenges
}

model UserChallenge {
  id                  String    @id @default(cuid())
  userId              String
  challengeId         String
  currentValue        Int       @default(0)
  isCompleted         Boolean   @default(false)
  completedAt         DateTime?

  joinedAt            DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  user                User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge           ReadingChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  @@unique([userId, challengeId])
  @@index([userId])
  @@index([challengeId])
  @@index([isCompleted])
}

model ReadingStreak {
  id                  String    @id @default(cuid())
  userId              String    @unique
  currentStreak       Int       @default(0)
  longestStreak       Int       @default(0)
  lastReadDate        DateTime?

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ReviewHelpful {
  id                  String    @id @default(cuid())
  userId              String
  readingEntryId      String    // The review being marked helpful

  createdAt           DateTime  @default(now())

  // Relations
  user                User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  readingEntry        ReadingEntry @relation(fields: [readingEntryId], references: [id], onDelete: Cascade)

  @@unique([userId, readingEntryId])
  @@index([userId])
  @@index([readingEntryId])
}

model ReviewComment {
  id                String    @id @default(cuid())
  readingEntryId    String    // The review being commented on
  userId            String
  comment           String    @db.Text
  parentId          String?   // For threaded replies

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  readingEntry      ReadingEntry      @relation(fields: [readingEntryId], references: [id], onDelete: Cascade)
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent            ReviewComment?    @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies           ReviewComment[]   @relation("CommentReplies")

  @@index([readingEntryId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
}

// ============================================
// PHASE 3: SOCIAL FEATURES (Track A)
// ============================================

model Follow {
  id                String    @id @default(cuid())
  followerId        String
  followingId       String

  createdAt         DateTime  @default(now())

  // Relations
  follower          User      @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  following         User      @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId]) // Can't follow same user twice
  @@index([followerId])
  @@index([followingId])
}

model Activity {
  id                String    @id @default(cuid())
  userId            String
  type              String    // "finished_book", "started_book", "rated_book", "reviewed_book", "followed_user"
  data              String    @db.Text // JSON data about the activity

  createdAt         DateTime  @default(now())

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([type])
}

model Notification {
  id                String    @id @default(cuid())
  userId            String
  type              String    // "follow", "comment", "review_helpful", "badge_earned", "challenge_completed", "goal_achieved"
  title             String
  message           String    @db.Text
  data              String?   @db.Text // JSON data with additional context (e.g., user ID, book ID, etc.)
  isRead            Boolean   @default(false)
  link              String?   // Optional link to related content

  createdAt         DateTime  @default(now())

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@index([userId, isRead])
}

model BookClub {
  id                String    @id @default(cuid())
  name              String
  description       String?   @db.Text
  isPublic          Boolean   @default(true)  // Public or private club
  coverImage        String?   // Optional club cover image URL
  maxMembers        Int?      // Optional member limit
  createdById       String

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  createdBy         User      @relation("CreatedBookClubs", fields: [createdById], references: [id], onDelete: Cascade)
  members           BookClubMember[]
  currentRead       BookClubBook?    @relation("CurrentRead")
  books             BookClubBook[]
  discussions       BookClubDiscussion[]
  meetings          BookClubMeeting[]

  @@index([createdById])
  @@index([isPublic])
  @@index([createdAt])
}

model BookClubMember {
  id                String    @id @default(cuid())
  bookClubId        String
  userId            String
  role              String    @default("member")  // "admin", "moderator", "member"
  joinedAt          DateTime  @default(now())

  // Relations
  bookClub          BookClub  @relation(fields: [bookClubId], references: [id], onDelete: Cascade)
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([bookClubId, userId])  // Can't join same club twice
  @@index([bookClubId])
  @@index([userId])
}

model BookClubBook {
  id                String    @id @default(cuid())
  bookClubId        String
  bookId            String
  status            String    @default("upcoming")  // "upcoming", "current", "completed"
  startDate         DateTime?
  endDate           DateTime?
  addedById         String

  createdAt         DateTime  @default(now())

  // Relations
  bookClub          BookClub  @relation(fields: [bookClubId], references: [id], onDelete: Cascade)
  currentReadClub   BookClub? @relation("CurrentRead", fields: [currentReadClubId], references: [id])
  currentReadClubId String?   @unique
  book              Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  addedBy           User      @relation(fields: [addedById], references: [id])

  @@index([bookClubId])
  @@index([bookId])
  @@index([status])
}

model BookClubDiscussion {
  id                String    @id @default(cuid())
  bookClubId        String
  userId            String
  message           String    @db.Text
  replyToId         String?   // For threaded discussions

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  bookClub          BookClub  @relation(fields: [bookClubId], references: [id], onDelete: Cascade)
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  replyTo           BookClubDiscussion? @relation("DiscussionReplies", fields: [replyToId], references: [id])
  replies           BookClubDiscussion[] @relation("DiscussionReplies")

  @@index([bookClubId])
  @@index([userId])
  @@index([createdAt])
  @@index([replyToId])
}

model BookClubMeeting {
  id                String    @id @default(cuid())
  bookClubId        String
  title             String
  description       String?   @db.Text
  scheduledAt       DateTime
  duration          Int       // Duration in minutes
  agoraChannelName  String    // Agora channel name
  agoraAppId        String?   // Store app ID for reference
  recordingUrl      String?   // Recording URL if available
  status            String    @default("scheduled") // scheduled, in_progress, completed, cancelled
  createdById       String

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  bookClub          BookClub  @relation(fields: [bookClubId], references: [id], onDelete: Cascade)
  createdBy         User      @relation("CreatedMeetings", fields: [createdById], references: [id])

  @@index([bookClubId])
  @@index([scheduledAt])
  @@index([status])
}

// ============================================
// PHASE 3: ADVANCED BOOK MANAGEMENT (Track B)
// ============================================

model Collection {
  id                String    @id @default(cuid())
  userId            String
  name              String
  description       String?   @db.Text
  isPublic          Boolean   @default(false)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  books             CollectionBook[]

  @@index([userId])
  @@index([isPublic])
}

model CollectionBook {
  id                String    @id @default(cuid())
  collectionId      String
  bookId            String

  addedAt           DateTime  @default(now())

  // Relations
  collection        Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  book              Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([collectionId, bookId])
  @@index([collectionId])
  @@index([bookId])
}

model Tag {
  id                String    @id @default(cuid())
  userId            String
  name              String

  createdAt         DateTime  @default(now())

  // Relations
  readingEntries    ReadingEntryTag[]

  @@unique([userId, name]) // User can't have duplicate tag names
  @@index([userId])
}

model ReadingEntryTag {
  id                String    @id @default(cuid())
  readingEntryId    String
  tagId             String

  createdAt         DateTime  @default(now())

  // Relations
  readingEntry      ReadingEntry @relation(fields: [readingEntryId], references: [id], onDelete: Cascade)
  tag               Tag       @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([readingEntryId, tagId])
  @@index([readingEntryId])
  @@index([tagId])
}

model ReadingGoal {
  id                String    @id @default(cuid())
  userId            String
  year              Int
  targetBooks       Int
  currentBooks      Int       @default(0)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, year]) // One goal per year per user
  @@index([userId])
  @@index([year])
}

// ============================================
// PHASE 3: READING EXPERIENCE (Track D)
// ============================================

model Note {
  id                String    @id @default(cuid())
  userId            String
  bookId            String
  content           String    @db.Text
  page              Int?
  chapter           String?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  book              Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([bookId])
  @@index([createdAt])
}

model Highlight {
  id                String    @id @default(cuid())
  userId            String
  bookId            String
  text              String    @db.Text
  page              Int?
  chapter           String?
  color             String?   @default("yellow")

  createdAt         DateTime  @default(now())

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  book              Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([bookId])
}

model Quote {
  id                String    @id @default(cuid())
  userId            String
  bookId            String
  text              String    @db.Text
  page              Int?
  isFavorite        Boolean   @default(false)

  createdAt         DateTime  @default(now())

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  book              Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([bookId])
  @@index([isFavorite])
}

model ReadingSession {
  id                String    @id @default(cuid())
  userId            String
  bookId            String
  startTime         DateTime
  endTime           DateTime?
  durationMinutes   Int?
  pagesRead         Int?

  createdAt         DateTime  @default(now())

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  book              Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([bookId])
  @@index([startTime])
}

model SearchHistory {
  id                String    @id @default(cuid())
  userId            String
  query             String    // The search query text
  filters           String?   @db.Text // JSON string with filters (genre, year, rating, sortBy)
  resultCount       Int       @default(0) // Number of results returned

  createdAt         DateTime  @default(now())

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([userId, createdAt]) // Composite for fetching user's recent searches
}
